# Lab (2) Notes
Ahmed M. Al-Qassas [qassas.ahmed@mau.edu.eg](qassas.ahmed@mau.edu.eg)  
Spring 2023-24
---
## 0. Review on Lab (1)

| Collection | Mutable | Ordered | Unique    |
|------------|---------|---------|-----------|
| List       | Yes     | Yes     | No        |
| Tuple      | No      | Yes     | No        |
| Set        | No      | No      | Yes       |
| Dictionary | Yes     | No      | Keys only |

## 1. Introduction
In computer science, to communicate with the computer hardware, the user needs some languages for programming purposes, such as C#, Python, and Java. **For constructing the languages, there are some rules to be followed. The rules are called the
grammar for that programming language.**

## 2. Grammar
A grammar is a _**set of rules**_ to defne a **valid** sentence in any language.  
A grammar (G) consists of four tuples:  
**G = {V<sub>N</sub>, ∑, P, S}** , where
* **V<sub>N</sub>**: Set of Non-terminals.
* **∑**: Set fo terminals.
*  **P**: Production rule.
* **S**: Start Symbol.  

**Non-terminal (V<sub>N</sub>)** symbols are those symbols which can be replaced multiple times (UPPERCASE letters).  
**Terminal symbols (∑)** are those symbols which cannot be replaced further (lowercase letters).  
In most of the cases, a grammar is represented by **only the production rules**.   

### Example 1  
Find the language generated by the following grammar:   
**S → aSa/aba**  

###### Solution 
According to the production rules, we can replace **`S`** (start symbol) with one of two options:
1. **aSa**: which contains one _non-terminal Symbol_ **`S`**, meaning that _the production is not done yet_ because **`S`** can be replaced again.
2. **aba**: which is all _terminal symbols_ meaning that the production is complete.  

Considering these two options, we have a fixed **`a`** at the beginning of the word **a**Sa or **a**ba.  

The next symbol can be **`S`** again. S → aSa → aaSaa → aaaSaaa ... and this may continue until **`aba`** (terminal) is reached ... → aaa(aSa)aaa → **a<sup>n</sup>ba<sup>n</sup>**.  

Hence, for **`n`** replacements of **`S`**, we get **a<sup>n</sup>ba<sup>n</sup>**:  

L(G) = **a<sup>n</sup>ba<sup>n</sup>**, n > 0.

### Example 2
Find the language generated by the following grammar:  
**S → aSb/aAb, A → bAa/ba**    

###### Solution
According to the production rules, from the **`S`** we can reach one of two options which are **aSb** or **aAb**. Both options contain non-terminals which are:
1. **`S`**: which can be replaced over and over again with 1st rule as S → a**S**b → a(a**S**b)b → ...  **a<sup>n</sup>Sb<sup>n</sup>**. The first rule will continue produce **a<sup>n</sup>Sb<sup>n</sup>** until the **`S`** is replaced with **aAb**; **a<sup>n</sup>Ab<sup>n</sup>**. Then we can move to the second rule through the non-terminal **`A`**.
2. **`A`**: We start here with **a<sup>n</sup>Ab<sup>n</sup>**, where **`A`** can be replaced with **ba** which will end the production or **bAa** which will keep the production going. Put **a<sup>n</sup>(A)b<sup>n</sup>** and replace **`A`** with **bAa** **a<sup>n</sup>(A)b<sup>n</sup>** → **a<sup>n</sup>(bAa)b<sup>n</sup>** → **a<sup>n</sup>b(bAa)ab<sup>n</sup>** → ...  **a<sup>n</sup>b<sup>m</sup>a<sup>m</sup>b<sup>n</sup>**  

L(G) = **a<sup>n</sup>b<sup>m</sup>a<sup>m</sup>b<sup>n</sup>** , m, n > 0.

### Example 3: Try it yourself
What language is generated by the grammar:  
S → aSb, S → A, A → aA  
**Hint**: will **a** and **b** be equal?

### Example 4: Try it yourself
What language is generated by the grammar:  
S → aSa/aBa, A → Ba/b  
**Hint**: Is the production rule proper?

## 3. The Chomsky Hierarchy
It is hierarchy of formal languages based on the properties of the grammars
required to generate the languages. Chomsky classified the grammar into **four** types depending on the _production_ rule:  

| Grammar  | Language                   | Machine Format          |
|:---------|:---------------------------|:------------------------|
| _Type 0_ | Unrestricted Language      | Turing Machine          |
| _Type 1_ | Context-sensitive language | Linear bounded automata |
| _Type 2_ | Context-free language      | Push down automata      |
| _Type 3_ | Regular Expression         | Finite automata (FSM)   |

### Example 5
In the given _**context-free grammar**_, S is the start symbol, a and b are terminals, and ε denotes the
empty string.  
**S → aSa/bSb/a/b/ε**, Which of the following strings is **NOT** generated by the grammar?
1. aaaa
2. baba
3. abba
4. babaaabab
### Example 6
In the given context-free grammar, S is the start symbol, a and b are terminals, and ε denotes the
empty string.  
**S → aSAb/ε, A → bA/ε**, The grammar generates the language:
1. ((a + b)\*b)\*
2. {a<sup>m</sup>b<sup>n</sup> | m ≤ n }
3. {a<sup>m</sup>b<sup>n</sup> | m = n }
4. a\*b\*
### Example 7
The two grammars given generate a language over the alphabet (x, y, z)  
**G1: S → x | z | xS | zS | yB, B → y | z | yB | zB**  
**G2: S → y | z | yS | zS | xB, B → y | yS**    

Which of the following choices describe the properties satisfied by the strings in these languages?  

1. **G1:** No y appears before any x,
**G2:** Every x is followed by at least one y.
2. **G1:** No y appears before any x,
**G2:** No x appears before any y.
3. **G1:** No y appears after any x,
**G2:** Every x is followed by at least one y.
4. **G1:** No y appears after any x,
**G2:** Every y is followed by at least one x.

## 4. Brief Introduction to Python's re Module
[Regular Expression HOWTO](https://docs.python.org/3/howto/regex.html)  
In automata theory, Regular expression describes patterns of strings that can be recognized by **finite automata**, which are mathematical models of computation used in computer science. Regex are  available in Python using the **re** module, which can be used to match, validate or modify strings.  

* Most letters and characters will simply match themselves.
* Metacharacters do not match themselves.
* Special sequences beginning with '\'.

| Meta Characters | Description                   |
|:----------------|:------------------------------|
| .               | any character except newline. |
| +               | one or more occurrence.       |
| *               | zero or more occurrence.      |
| ^               | starts with                   |
| $               | ends with                     |
| ?               | zero or one occurrence.      |
| { }             | exact number of occurrence.   |
| \|              | either or                     |
| ()              | capture and group             |


| Special Characters | Description                   |
|:-------------------|:------------------------------|
| \w                 | any alphanumeric char         |
| \W                 | any non-alphanumeric          |
| \d                 | any decimal digits            |
| \D                 | any non-digit char            |
| \s                 | any white space char          |
| \S                 | any non-white space char      |
| \A                 | the beginning of a string     |
| \Z                 | the end of a string           |
| \b                 | the beginning/end of word     |
| \B                 | **not** beginning/end of word |

### Repeating Strings
* The `+` means one or more strings: **"ab+c"** can be **"abc"** or **"abbc"** or **"abbbbc"** but not **"ac"**  .
Here, L(G) = ab<sup>n</sup>c , n > 0.
* The `*` means zero or more strings: **"ab*c"** can be **"abc"** or **"abbc"** or **"abbbbc"** and **"ac"**.  
Here, L(G) = ab<sup>n</sup>c , n ≥ 0.
### Compiling Regex
Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions.
```python
import re
pattern = re.compile('ab*c')
print(pattern)
```
### Performing Matches
check [code example](main.py)
1. Using the `*` meta character
```python
import re

pattern_star = re.compile('ab*c')
print(re.fullmatch(pattern_star, "abbbc"))
print(re.fullmatch(pattern_star, "ac"))
```
2. Using the `+` meta character
```python
import re

pattern_plus = re.compile('ab+c')
print(re.fullmatch(pattern_plus, "abbbc"))
print(re.fullmatch(pattern_plus, "ac"))
```
## Thank You